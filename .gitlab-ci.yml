stages:
- "test"
- "clean"
- "build"
- "staging"
- "deploy"

# Build template definition
.build-template: &build_definition
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:v1.14.0-debug
    entrypoint: [""]
  script:
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/deploy/Dockerfile --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  tags:
    - kubernetes-runner

# # Stage to build the Pytest Docker image
# build-pytest-image:
#   stage: build-image
#   <<: *build_definition
#   environment:
#     name: testing
#   variables:
#     IMAGE_TAG: "testing-${CI_COMMIT_REF_SLUG}"
#   script:
#     - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/Dockerfile.pytest --destination $CI_REGISTRY_IMAGE:pytest-$CI_COMMIT_REF_SLUG
#   only:
#     - main
#     - tags

services:
- name: docker:dind
  alias: docker
variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: "/certs/client"

.kube-context:
  image: bitnami/kubectl:latest
  tags:
    - kubernetes-runner
    - deploy-runner

.initial-setup:
  stage: test
  image: python:3.10.8-slim-buster
  tags:
    - docker-runner
  except:
    - tags
  variables:
    PIP_DEFAULT_TIMEOUT: 300
  before_script:
    - apt-get update && apt-get install -y curl gnupg
    - pip install poetry==1.7.1 Jinja2
    - poetry config virtualenvs.create false
    - poetry install -E all  # Ensure all extras, including dev dependencies, are installed
  # artifacts:
  #   paths:
  #     - ./deploy/kube/*.yml

black:
  when: manual
  extends:
  - .initial-setup
  script:
  - black --check .

flake8:
  when: manual
  extends:
  - .initial-setup
  script:
  - flake8 --count .

mypy:
  when: manual
  extends:
  - .initial-setup
  script:
  - mypy .

# pytest:
#   stage: test
#   image: docker:19.03.12
#   services:
#     - docker:19.03.12-dind
#   variables:
#     DOCKER_HOST: tcp://docker:2375
#     DOCKER_TLS_CERTDIR: "/certs"
#     SLACK_FASTAPI_DB_HOST: database
#     POSTGRES_PASSWORD: slack_fastapi
#     POSTGRES_USER: slack_fastapi
#     POSTGRES_DB: slack_fastapi
#   script:
#     - docker pull $CI_REGISTRY_IMAGE:pytest-$CI_COMMIT_REF_SLUG
#     - docker run --name pytest-container $CI_REGISTRY_IMAGE:pytest-$CI_COMMIT_REF_SLUG pytest -vv --junitxml=report.xml --cov="slack_fastapi" .
#   dependencies:
#     - build-pytest-image
#   only:
#     - main
#     - tags

pytest:
  stage: test
  extends:
    - .initial-setup
  services:
    - name: postgres:13.8-bullseye
      alias: database
  variables:
    SLACK_FASTAPI_DB_HOST: database
    POSTGRES_PASSWORD: slack_fastapi
    POSTGRES_USER: slack_fastapi
    POSTGRES_DB: slack_fastapi
  before_script:
    - apt-get update -y
    - apt-get install -y libgl1-mesa-dev wait-for-it
    - pip install pytest pytest-cov
  script:
    - wait-for-it -t 180 $SLACK_FASTAPI_DB_HOST:5432
    - pytest -vv --junitxml=report.xml --cov="slack_fastapi" .
    - coverage xml
  artifacts:
    when: always
    reports:
      junit: report.xml

stage-clean:
  stage: clean
  extends:
  - .kube-context
  script:
    - rm ./deploy/kube/namespace.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/*.yml
  environment:
    name: staging
  when: manual
  dependencies:
    - pytest

clean:
  stage: clean
  extends:
  - .kube-context
  script:
    - rm ./deploy/kube/namespace.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/*.yml
  environment:
    name: production
  when: manual
  dependencies:
    - pytest

# Build stages for different environments
stage-build:
  <<: *build_definition
  environment:
    name: staging
  variables:
    IMAGE_TAG: "staging-${CI_COMMIT_REF_SLUG}"

build:
  <<: *build_definition
  environment:
    name: production
  variables:
    IMAGE_TAG: "production-${CI_COMMIT_REF_SLUG}"

staging:
  stage: staging
  extends:
  - .kube-context
  script:
    - jinja2 ./deploy/kube/templates/app.yml.j2 -D app_image=${CI_REGISTRY_IMAGE}:staging-${CI_COMMIT_REF_SLUG} -D num_replicas=2 > ./deploy/kube/app.yml
    - jinja2 ./deploy/kube/templates/db.yml.j2 -D db_image=${CI_REGISTRY_IMAGE}:staging-${CI_COMMIT_REF_SLUG} > ./deploy/kube/db.yml
    - jinja2 ./deploy/kube/templates/namespace.yml.j2 -D namespace_name=staging > ./deploy/kube/namespace.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/namespace.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/db.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/app.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/rabbit.yml
  only:
    - tags
  dependencies:
    - pytest

deploy:
  stage: deploy
  extends:
  - .kube-context
  script:
    - jinja2 ./deploy/kube/templates/app.yml.j2 -D app_image=${CI_REGISTRY_IMAGE}:production-${CI_COMMIT_REF_SLUG} -D num_replicas=2 > ./deploy/kube/app.yml
    - jinja2 ./deploy/kube/templates/db.yml.j2 -D db_image=${CI_REGISTRY_IMAGE}:production-${CI_COMMIT_REF_SLUG} > ./deploy/kube/db.yml
    - jinja2 ./deploy/kube/templates/namespace.yml.j2 -D namespace_name=production > ./deploy/kube/namespace.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/namespace.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/db.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/app.yml
    - kubectl --context $KUBE_CONTEXT apply -f ./deploy/kube/rabbit.yml
  only:
    - main
  dependencies:
    - pytest
